// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
}
//ctrl + G to go to a particular line
//~~~~~~ Proctoring and Assessment starts at line 891 ~~~~~~~~
//~~~~~~ Client and Project starts at line 301 ~~~~~~~
//~~~~~~ Opportunity starts at line 375 ~~~~~~~
//~~~~~~ Time Slots and related starts at line 608 ~~~~~~~
//~~~~~~ Review and Dispute starts at line 710 ~~~~~~~
//~~~~~~ Payment and related starts at line 841 ~~~~~~~

//~~~~~~~~~ Auth ~~~~~~~~~

enum AuthProvider {
  LOCAL
  GOOGLE
  LINKEDIN
}

model User {
  id            String  @id @default(cuid())
  email         String  @unique
  emailVerified Boolean @default(false)
  phone         String? @unique
  phoneVerified Boolean @default(false)
  passwordHash  String?
  role          Role    @default(AGENT)
  status        Status  @default(PENDING)

  googleId       String?      @unique //oAuth Google Id
  profilePicture String? //Profile Picture received from Google
  provider       AuthProvider @default(LOCAL) // Authentication done through Local/Google etc

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  otps  OTP[] //OTPs received for the user
  agent Agent?
}

model OTP {
  id        String   @id @default(cuid())
  code      String
  type      OTPType
  target    String //email or phone the otp was sent to
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  consumed  Boolean  @default(false)
  createdAt DateTime @default(now())
}

enum OTPType {
  EMAIL
  PHONE
}

enum Role {
  AGENT
  ADMIN
}

enum Status {
  ACTIVE
  INACTIVE
  PENDING
}

//~~~~~~~~~ Step 1 ~~~~~~~~~

model Agent {
  id         String   @id @default(cuid())
  userId     String   @unique
  user       User     @relation(fields: [userId], references: [id], onDelete: SetNull)
  firstName  String
  middleName String?
  lastName   String?
  dob        DateTime

  //Bank Details (Essential for NEFT)
  bankAccountNumber String?
  bankIFSC          String?
  accountHolderName String?
  panNumber         String? // Required for tax compliance in India

  //Shift & Availability
  preferredShift WorkShift @default(FLEXIBLE) // Agent's preferred shift timing
  hoursPerDay    Int       @default(8) // Maximum hours agent can work per day

  qualifications  Qualification[]
  profilePhotoUrl String? // URL to photo in cloud storage

  hasExperience Boolean      @default(false)
  experiences   Experience[]

  isEmployed Boolean     @default(false)
  employment Employment?

  skills    String[]
  languages String[]

  kycStatus    KycStatus     @default(PENDING)
  kycDocuments KYCDocument[] //KYC Information of an agent

  assessedCandidate Candidate[]

  //languageTests  LanguageProficiencyTest[] -> Review with Piyush

  //agreements     Agreement[]  -> Review with Piyush

  reviews        Review[] //Reviews related to the agent (platform reviews, performance reviews, etc.)
  GigApplication GigApplication[]
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  Dispute        Dispute[]
}

enum WorkShift {
  MORNING_9_5 // 09:00 - 17:00 (9 AM - 5 PM)
  AFTERNOON_1_9 // 13:00 - 21:00 (1 PM - 9 PM)
  EVENING_5_1 // 17:00 - 01:00 (5 PM - 1 AM next day)
  NIGHT_1_9 // 01:00 - 09:00 (1 AM - 9 AM next day)
  FLEXIBLE // Any time (agent decides)
  CUSTOM // Custom hours (to be specified separately)
}


model Qualification {
  id        String            @id @default(cuid())
  agentId   String
  agent     Agent             @relation(fields: [agentId], references: [id], onDelete: Cascade)
  type      QualificationType 
  degree    String?
  field     QualificationField?
  institution String?
  startYear   Int?
  endYear     Int?
  grade       String?
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
}

enum QualificationType {
  HIGH_SCHOOL
  DIPLOMA
  BACHELORS
  MASTERS
  PHD
  CERTIFICATION
}

enum QualificationField {
  CS_IT
  ENGINEERING
  DATA_AI
  DESIGN
  BUSINESS
  MARKETING
  FINANCE
  HR
  MEDIA_COMM
  LANGUAGE
  HEALTHCARE
  EDUCATION
  LAW
  SCIENCE
  OTHER
}

enum Industry {
  BPO
  CONTENT
  TECH
  MARKETING
  SALES
  FINANCE
  HR
  EDUCATION
  HEALTHCARE
  ECOMMERCE
  LOGISTICS
  IT_SERVICES
  AI_ML
  DATA_SCIENCE
  OTHER
}

enum Vertical {
  INBOUND_CALL
  CHAT_SUPPORT
  MULTI_CHANNEL_SUPPORT
  PROMPT_ENGINEERING
  DATA_ANNOTATION
  MODEL_EVALUATION
  FINE_TUNING
  TRANSCRIPTION
  TRANSLATION
  UI_UX
  DOCUMENTATION
  SEO
  SOCIAL_MEDIA
  EMAIL_MARKETING
  COPYWRITING
  QA_TESTING
  API_INTEGRATION
  DATA_MIGRATION
  DEVOPS
  FIELD_VISIT
  HARDWARE_AUDIT
  TECH_SUPPORT
  OTHER
}

model Experience {
  id      String @id @default(cuid())
  agentId String
  agent   Agent  @relation(fields: [agentId], references: [id], onDelete: Cascade)

  experienceMin Int?  //Lower value of a range eg. 5 in (5-10) experience
  experienceMax Int? //Higher value of a range eg. 10 in (5-10) experience
  jobTitle      String?
  industry      Industry? //To have a fixed set of industry data for better recommendations
  vertical      Vertical? //To have a fixed set of vertical data for better recommendations
  companyName   String?   

  startDate DateTime
  endDate   DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Employment {
  id      String @id @default(cuid())
  agentId String @unique
  agent   Agent  @relation(fields: [agentId], references: [id], onDelete: Cascade)

  jobTitle    String?
  industry    Industry?
  vertical    Vertical?
  companyName String?

  startDate DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model KYCDocument {
  id      String @id @default(cuid())
  agentId String
  agent   Agent  @relation(fields: [agentId], references: [id], onDelete: Cascade)

  documentType   String // "AADHAR", "PAN"
  documentNumber String // AADHAR/PAN Number
  holderName     String? // Name mentioned in Aadhar/Pan

  // File storage
  documentUrl   String? // URL to encrypted document image
  frontImageUrl String? // URL to front image of document 
  backImageUrl  String? // URL to back image of document

  // Verification
  verificationStatus KycStatus @default(PENDING) // pending, verified, rejected
  verifiedAt         DateTime?

  // Metadata for audit
  uploadedAt DateTime @default(now())
  verifiedBy String? // Admin/API that verifies

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum KycStatus {
  PENDING
  APPROVED
  REJECTED
}

enum KycType {
  AADHAR
  PAN
}

//To be Reviewed with Piyush
// Model LanguageProficiencyTest
// Model Agreement 

//~~~~~~~~~ Step 2 ~~~~~~~~~

model Client {
  id String @id @default(cuid())

  // Basic Info
  name  String //Company/Client Name 
  email String @unique //Company/Client Email

  // Company Info
  companyName String
  logo        String?
  website     String?
  phone       String?

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  reviews  Review[] //Reviews related to the client
  disputes Dispute[] //Disputes related to the client

  // Relationships
  projects Project[]
}

model Project {
  id String @id @default(cuid())

  // Basic Info
  title       String // "Customer Support Team - Q4 2024"
  description String // Detailed project requirements
  department  Industry? // "Customer Support", "Sales", "Technical Support"

  // Resource Requirements
  totalHoursNeeded Int // Total hours needed across all opportunities (e.g., 500 hours)
  agentsNeeded     Int // Total number of agents needed (e.g., 10 agents)
  skillsRequired   String[] // Required skills: ["Communication", "CRM", "Problem Solving"]

  // Budget & Timeline
  totalBudget     Decimal  @db.Decimal(10, 2) // Total budget for entire project
  currency        String   @default("INR")
  projectDeadline DateTime // Final completion date

  // Status
  status ProjectStatus @default(PLANNING)

  // Progress Tracking
  hoursCompleted Int @default(0) // Track progress
  agentsHired    Int @default(0) // How many agents hired so far

  // Client Info
  clientId String
  client   Client @relation(fields: [clientId], references: [id], onDelete: Cascade)

  // Relationships
  opportunities Opportunity[] // Multiple opportunities created from this project

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum ProjectStatus {
  PLANNING // Client defining requirements, no opportunities yet
  ACTIVE // Opportunities created, hiring in progress
  IN_PROGRESS // Work started, agents working
  COMPLETED // All work finished
  ON_HOLD // Temporarily paused
  CANCELLED // Project cancelled
  CLOSED // Finalized (completed or cancelled)
}

//~~~~~~~~~ Step 3 ~~~~~~~~~

model Opportunity {
  id String @id @default(cuid())

  // Basic Info
  title       String //Opportunity Title
  description String //Description about Opportunity
  category    ServiceCategory @default(BPO) //Type of service agent has to offer (BPO/Content/LLM)

  // Work Details
  processType ProcessType //How work happens/kind of work to be done

  //Time & Duration  
  deadline DateTime //Apply before this date 

  //Payment
  payAmount   Decimal     @db.Decimal(10, 2) //Money to be paid for the work
  currency    String      @default("INR") //Currency in which money would be paid
  paymentType PaymentType @default(FIXED) //Payment Type like Hourly/Fixed etc

  //Status & Metadata
  status     OpportunityStatus @default(OPEN) //Lifecycle of Opportunity(IN_PROGRESS, COMPLETED, CANCELLED)
  visibility VisibilityLevel   @default(PUBLIC) // Opportunity visible to : (PUBLIC, PRIVATE etc)

  //Project that this opportunity is connected to
  projectId String // FK to brand
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  //Skills/Qualifications/Scores Required(To be given by client/admin)

  minimumSkills         String[]
  requiredLanguages     String[]
  minimumQualifications Json?
  minimumL1Score        LanguageProficiency @default(A1)
  preferredExperience   Json?

  //Relationships
  applications        GigApplication[]
  clientScheduleSlots ClientScheduleSlot[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum ServiceCategory {
  BPO
  CONTENT
  TECH
}

enum ProcessType {
  INBOUND_CALL // Voice support
  CHAT_SUPPORT // Live chat / text
  DATA_ANNOTATION // Labeling / tagging
  PROMPT_ENGINEERING // LLM prompt & refinement
  TECH_SUPPORT // General technical help
  QA_TESTING // Quality / testing tasks
  DOCUMENTATION // Writing / knowledge base
}

enum DurationType {
  HOURS
  DAYS
  WEEKS
  MONTHS
}

enum OpportunityStatus {
  OPEN // Available, no issues
  IN_PROGRESS // Someone working on it
  ON_HOLD // Paused due to issues
  CANCELLED // Cancelled by client or agent
  COMPLETED // Finished successfully
  CLOSED // Ended (completed or cancelled)
}

enum LanguageProficiency {
  A1
  A2
  B1
  B2
  C1
  C2
}

enum PaymentType {
  FIXED //Fixed Pay for the work
  HOURLY //Hourly Pay for the work
  MILESTONE_BASIS //Pay for a particular milestone in opportunity
}

enum ApplicationStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum VisibilityLevel {
  PUBLIC
  PRIVATE
  DRAFT
}

model GigApplication {
  id String @id @default(cuid())

  agentId String //Agent Applying for Opportunity
  agent   Agent  @relation(fields: [agentId], references: [id], onDelete: SetNull)

  opportunityId String //Opportunity agent applied for
  opportunity   Opportunity @relation(fields: [opportunityId], references: [id], onDelete: SetNull)

  // Application Status
  status ApplicationStatus @default(PENDING) // PENDING, ACCEPTED, REJECTED

  //Test Details
  testPassed Boolean @default(false)

  //Relations
  selectedGig SelectedGig?
  dispute     Dispute[]

  // Timestamps
  appliedAt  DateTime  @default(now())
  hireDateAt DateTime? //Date & Time at which the agent is succesfully accepted for the gig
}

model SelectedGig {
  id String @id @default(cuid())

  // Foreign Keys
  gigApplicationId String         @unique //Application which the agent applied for
  gigApplication   GigApplication @relation(fields: [gigApplicationId], references: [id], onDelete: Cascade)

  // Status
  status GigStatus @default(OPEN) // IN_PROGRESS/ON_HOLD/COMPLETED

  // BYOD/CCaaS Setup(Yet to be filled)

  // Relationships
  activityLogs   ActivityLog[] //Activity Logs happened during the gig 
  submittedWorks SubmittedWork[] //Works/Deliverables of particular gig
  reviews        Review[]
  disputes       Dispute[] //Disputes related to any gig work
  AgentWorkSlot  AgentWorkSlot?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum GigStatus {
  OPEN
  IN_PROGRESS
  COMPLETED
  CANCELLED
  ON_HOLD
  CLOSED //Either completed or cancelled and hence closed
}

model ActivityLog {
  id String @id @default(cuid())

  selectedGigId String
  selectedGig   SelectedGig @relation(fields: [selectedGigId], references: [id], onDelete: Cascade)

  // Activity Details
  type        ActivityType //Type of Activity
  description String?

  // When it happened
  startTime DateTime  @default(now())
  endTime   DateTime? // Null if still ongoing (e.g., active session)

  // For Tickets raised
  ticketCount Int? // Number of tickets handled in this period

  createdAt DateTime @default(now())
}

enum ActivityType {
  LOGIN
  LOGOUT
  BREAK
  TICKET_RAISED
}

model SubmittedWork {
  id String @id @default(cuid())

  selectedGigId String
  selectedGig   SelectedGig @relation(fields: [selectedGigId], references: [id], onDelete: Cascade)

  // Work Details
  title       String
  description String?

  // Deliverables
  deliverables String[] // Array of file URLs or descriptions
  // Submission & Status
  status       SubmissionStatus @default(DRAFT) // Lifecycle: DRAFT â†’ PENDING â†’ UNDER_REVIEW â†’ APPROVED/REJECTED/REWORK_NEEDED â†’ COMPLETED
  submittedAt  DateTime? // When work was actually submitted (null if still DRAFT)

  // Review/Approval Details (consolidated here)
  reviewedBy      String? // Admin/Client ID who reviewed
  reviewedAt      DateTime? // When it was reviewed
  rejectionReason String? // Why it was rejected (if status = REJECTED)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  review   Review[] // Optional detailed reviews of this work
  disputes Dispute[] // Optional dispute related to this work
  Payment  Payment[]
}

enum SubmissionStatus {
  DRAFT // Work saved but not yet submitted
  PENDING // Submitted and awaiting review
  UNDER_REVIEW // Currently being reviewed by client/admin
  APPROVED // Work approved and accepted
  REJECTED // Work rejected, no rework
  REWORK_NEEDED // Work needs changes/improvements
  REWORK_SUBMITTED // Reworked version submitted, awaiting re-review
  COMPLETED // Final state - approved and processed
  CANCELLED // Submission cancelled by agent or admin
}

//~~~~~~~~~ Step 4 ~~~~~~~~~

// Time Slots of Weekly Schedule defined by company
model ClientScheduleSlot {
  id String @id @default(cuid())

  opportunityId String
  opportunity   Opportunity @relation(fields: [opportunityId], references: [id], onDelete: Cascade)

  // TimeSlot & Day of week
  timeSlot  TimeSlot // SLOT_09_10, SLOT_14_15, etc.
  dayOfWeek DayOfWeek // MONDAY, TUESDAY, etc.

  //ACTUAL SCHEDULING (calculated from timeSlot + date)
  startDateTime DateTime // 2025-11-13 09:00:00
  endDateTime   DateTime // 2025-11-13 10:00:00

  // How many agents needed for this slot
  agentsRequired Int @default(1)
  agentsFilled   Int @default(0) // How many agents selected this slot

  // Status
  status SlotStatus @default(OPEN) // OPEN, FULL, CLOSED

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  AgentWorkSlot AgentWorkSlot[] // Agents who selected this slot
}

// Agent's Selected Time Slots
model AgentWorkSlot {
  id String @id @default(cuid())

  // SCHEDULE SLOT (the fixed slot they chose)
  clientScheduleSlotId String
  clientScheduleSlot   ClientScheduleSlot @relation(fields: [clientScheduleSlotId], references: [id], onDelete: Cascade)

  //Gig Information for which the agent has time slot for
  selectedGigId String      @unique
  selectedGig   SelectedGig @relation(fields: [selectedGigId], references: [id], onDelete: Cascade)

  // STATUS
  status AgentSlotStatus @default(CONFIRMED)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum SlotStatus {
  OPEN // Available for selection
  FULL // All positions filled
  CLOSED // No longer available
}

enum TimeSlot {
  SLOT_00_01 // 12:00 AM - 01:00 AM
  SLOT_01_02 // 01:00 AM - 02:00 AM
  SLOT_02_03 // 02:00 AM - 03:00 AM
  SLOT_03_04 // 03:00 AM - 04:00 AM
  SLOT_04_05 // 04:00 AM - 05:00 AM
  SLOT_05_06 // 05:00 AM - 06:00 AM
  SLOT_06_07 // 06:00 AM - 07:00 AM
  SLOT_07_08 // 07:00 AM - 08:00 AM
  SLOT_08_09 // 08:00 AM - 09:00 AM
  SLOT_09_10 // 09:00 AM - 10:00 AM
  SLOT_10_11 // 10:00 AM - 11:00 AM
  SLOT_11_12 // 11:00 AM - 12:00 PM
  SLOT_12_13 // 12:00 PM - 01:00 PM
  SLOT_13_14 // 01:00 PM - 02:00 PM
  SLOT_14_15 // 02:00 PM - 03:00 PM
  SLOT_15_16 // 03:00 PM - 04:00 PM
  SLOT_16_17 // 04:00 PM - 05:00 PM
  SLOT_17_18 // 05:00 PM - 06:00 PM
  SLOT_18_19 // 06:00 PM - 07:00 PM
  SLOT_19_20 // 07:00 PM - 08:00 PM
  SLOT_20_21 // 08:00 PM - 09:00 PM
  SLOT_21_22 // 09:00 PM - 10:00 PM
  SLOT_22_23 // 10:00 PM - 11:00 PM
  SLOT_23_24 // 11:00 PM - 12:00 AM
}

enum DayOfWeek {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

enum AgentSlotStatus {
  CONFIRMED // Agent confirmed to work this slot
  IN_PROGRESS // Agent is currently working this slot
  COMPLETED // Agent finished working this slot
  CANCELLED // Agent cancelled this slot selection
  NO_SHOW // Agent didn't show up for the slot
  RESCHEDULED // Slot moved to different time
}

//~~~~~ Review/Feedback and Dispute ~~~~~

model Review {
  id String @id @default(cuid())

  // What is being reviewed (polymorphic approach)
  reviewType ReviewType // Type of review

  // Optional foreign keys (only one should be set based on reviewType)
  submittedWorkId String?
  submittedWork   SubmittedWork? @relation(fields: [submittedWorkId], references: [id], onDelete: Cascade)

  selectedGigId String?
  selectedGig   SelectedGig? @relation(fields: [selectedGigId], references: [id], onDelete: Cascade)

  agentId String? // For platform reviews or agent performance reviews
  agent   Agent?  @relation(fields: [agentId], references: [id], onDelete: Cascade)

  clientId String? // For client reviews
  client   Client? @relation(fields: [clientId], references: [id], onDelete: Cascade)

  // Who is reviewing
  reviewerId   String? // ID of the person giving the review
  reviewerType ReviewerType @default(ADMIN) // "AGENT", "CLIENT", "ADMIN", "SYSTEM"

  // Review content
  rating   Int? // 1-5 stars (required)
  category ReviewCategory @default(OVERALL) // What aspect is being reviewed
  comment  String? // Optional feedback text

  // Approval/Moderation
  approved Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum ReviewType {
  SUBMITTED_WORK // Review of a specific submitted work
  GIG // Overall review of a gig experience
  PLATFORM // Review of the platform itself
  AGENT // Client reviewing an agent's performance
  CLIENT // Agent reviewing a client/opportunity
}

enum ReviewCategory {
  OVERALL
  QUALITY
  COMMUNICATION
  TIMELINESS
  USER_EXPERIENCE
  PAYMENT
  SUPPORT
  ASSESSMENT
}

enum ReviewerType {
  AGENT // An agent reviewing (e.g., peer or client performance)
  CLIENT // Client providing feedback
  ADMIN // Platform admin / moderator
  SYSTEM // Auto-generated/system evaluation
  QA // Dedicated quality/audit reviewer
  TRAINER // L&D / onboarding evaluator
}

model Dispute {
  id String @id @default(cuid())

  // What is the dispute about (polymorphic approach)
  disputeType DisputeType // Type of dispute

  // Optional foreign keys (only one should be set based on disputeType)
  selectedGigId String?
  selectedGig   SelectedGig? @relation(fields: [selectedGigId], references: [id], onDelete: Cascade)

  gigApplicationId String?
  gigApplication   GigApplication? @relation(fields: [gigApplicationId], references: [id], onDelete: Cascade)

  submittedWorkId String?
  submittedWork   SubmittedWork? @relation(fields: [submittedWorkId], references: [id], onDelete: Cascade)

  paymentId String?
  payment   Payment? @relation(fields: [paymentId], references: [id], onDelete: Cascade)

  agentId String? // For agent-related disputes
  agent   Agent?  @relation(fields: [agentId], references: [id], onDelete: Cascade)

  clientId String? // For client-related disputes
  client   Client? @relation(fields: [clientId], references: [id], onDelete: Cascade)

  // Who raised the dispute
  raisedByType RaisedByType @default(USER)

  // Dispute Details
  title       String
  description String?

  // Evidence/Attachments
  evidenceUrls String[] // URLs to supporting documents/images

  // Status & Resolution
  status     DisputeStatus @default(OPEN) // Lifecycle of Dispute
  resolution String? // How it was resolved
  resolvedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum RaisedByType {
  AGENT // Agent Registered
  USER // General/Other Users
  ADMIN // Admin of the system
}

enum DisputeType {
  SUBMITTED_WORK // Dispute about work quality/delivery
  PAYMENT // Payment-related dispute
  GIG // General gig-related issue
  PLATFORM // Platform functionality/policy issue
  AGENT_CONDUCT // Agent behavior/conduct issue
  OTHER // Other issues
}

enum DisputeStatus {
  OPEN // Newly created, awaiting review
  UNDER_REVIEW // Being investigated by admin
  RESOLVED // Successfully resolved
  ESCALATED // Escalated to higher authority
}

//~~~~~ Payment ~~~~~

enum PaymentStatus {
  PENDING // Payment created, awaiting transfer
  COMPLETED // Money transferred successfully
  FAILED // Transfer failed
  REFUNDED // Money returned (if needed)
}

enum PaymentMethod {
  NEFT // Most common in India
  UPI // For smaller amounts
  BANK_TRANSFER // Generic
}

model Payment {
  id String @id @default(uuid())

  //Core Payment Info
  amount   Float
  currency String        @default("INR")
  status   PaymentStatus @default(PENDING)
  method   PaymentMethod @default(BANK_TRANSFER)

  //Relations
  submittedWorkId String
  submittedWork   SubmittedWork @relation(fields: [submittedWorkId], references: [id])

  //NEFT Transfer Details (Essential)
  utrNumber    String?   @unique // alphanumeric code assigned to every electronic financial transaction in India
  transferDate DateTime? // When admin initiated NEFT

  //Basic Deductions
  grossAmount Float? // Total before deductions
  tdsAmount   Float  @default(0) // Tax deducted
  platformFee Float  @default(0) // Commission
  netAmount   Float? // Final amount transferred

  // Basic Tracking
  transactionId String?   @unique // Internal reference
  payoutDate    DateTime? // When money reached agent

  // Relationships
  disputes Dispute[] // Disputes related to this payment

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}


//~~~~~~~~~~~~~~~~~~~~~~~Proctoring + Assessment Schema~~~~~~~~~~~~~~~~~~~~~~~~~~~

// Status of an assessment (Draft â†’ Scheduled â†’ Active â†’ Completed)
enum AssessmentStatus {
  DRAFT // Assessment is being created by admin
  SCHEDULED // Assessment is scheduled but not yet open
  ACTIVE // Assessment is currently available for candidates
  COMPLETED // Assessment period has ended
  ARCHIVED // Assessment is archived (no longer visible)
}

// Assessment Type (Language Proficiency vs Skill-Based)
enum AssessmentType {
  LANGUAGE // Language proficiency test
  SKILL    // Skill-based assessment (Sales, Marketing, etc.)
}

// Task Level within a question type
enum TaskLevel {
  LEVEL_1 // A1-A2 (Basic)
  LEVEL_2 // B1-B2 (Intermediate)
  LEVEL_3 // C1-C2 (Advanced)
}

// Types of questions supported in the platform
enum QuestionType {
  AUDIO_MCQ // Listening comprehension with multiple choice
  SPEAKING // Voice recording with ASR evaluation
  READING_MCQ // Reading comprehension with multiple choice
  WRITING // Essay or short answer text response
  FILL_BLANK // Fill in the blank (for grammar/vocabulary)
}

// CEFR proficiency levels (A1 = Basic, C2 = Mastery)
enum CEFRLevel {
  A1 // Beginner - Basic phrases and expressions
  A2 // Elementary - Simple everyday expressions
  B1 // Intermediate - Standard workplace discussions
  B2 // Upper Intermediate - Fluent and spontaneous
  C1 // Advanced - Complex subjects and detailed text
  C2 // Mastery - Express spontaneously and precisely
}

// Status for individual checks (camera, mic, network, etc.)
enum CheckStatus {
  PENDING // Check has not been performed yet
  PASSED // Check completed successfully
  FAILED // Check failed (may block proceeding)
  SKIPPED // Check was skipped (non-critical)
  RETRY // Check failed but candidate is retrying
}

// Identity verification progress status
enum VerificationStatus {
  NOT_STARTED // Verification hasn't begun
  IN_PROGRESS // Currently capturing/verifying face
  VERIFIED // Successfully verified
  FAILED // Verification failed (face mismatch, no face detected)
  FLAGGED // Suspicious activity detected, needs manual review
}

// Severity levels for proctoring violations
enum ViolationSeverity {
  INFO // Informational event (not a violation)
  LOW // Minor issue (brief look away, mouse leave)
  MEDIUM // Moderate issue (single tab switch, right-click)
  HIGH // Serious issue (multiple faces, extended absence)
  CRITICAL // Critical violation (dev tools, recording disabled)
}

// Types of violations that can be detected
enum ViolationType {
  FACE_NOT_DETECTED // No face visible in webcam
  MULTIPLE_FACES // More than one face detected
  FACE_MISMATCH // Different person detected
  TAB_SWITCH // Browser tab switched
  WINDOW_BLUR // Window lost focus
  FULLSCREEN_EXIT // Exited fullscreen mode
  COPY_ATTEMPT // Tried to copy text
  PASTE_ATTEMPT // Tried to paste text
  CUT_ATTEMPT // Tried to cut text
  RIGHT_CLICK // Right-click menu attempted
  DEV_TOOLS_OPEN // Browser developer tools detected
  MOUSE_LEAVE // Mouse left window boundaries
  KEYBOARD_SHORTCUT // Suspicious keyboard shortcut used
  SCREEN_SHARE_DISABLED // Screen sharing was disabled
  AUDIO_DISABLED // Microphone was disabled
  CAMERA_DISABLED // Camera was disabled
  BACKGROUND_NOISE // Suspicious background voice detected
  NETWORK_DISCONNECTED // Internet connection lost
  SUSPICIOUS_ACTIVITY // Other suspicious behavior
}

// Test session status tracking
enum SessionStatus {
  NOT_STARTED // Session created but not started
  PERMISSION_GRANTED // Candidate granted permissions
  DEVICE_TEST_IN_PROGRESS // System check ongoing
  DEVICE_TEST_COMPLETED // System check completed
  FULLSCREEN_ENTERED // Fullscreen mode activated
  IN_PROGRESS // Test is currently ongoing
  PAUSED // Test paused (due to disconnection or violation)
  COMPLETED // Test completed successfully
  AUTO_SUBMITTED // Test auto-submitted (time up or violations)
  TERMINATED // Test forcibly terminated by system/admin
}

// Blacklist reasons
enum BlacklistReason {
  VIOLATION_THRESHOLD // Exceeded maximum violations
  CRITICAL_VIOLATION // Single critical violation (dev tools, etc.)
  MANUAL_ADMIN // Manually blacklisted by admin
  SUSPICIOUS_PATTERN // Pattern of suspicious behavior
  IDENTITY_FRAUD // Identity verification fraud detected
}

// ============================================================================
// USER & ROLE MANAGEMENT
// ============================================================================

// Super Admin table - Full system access
// Note: Candidates are managed in the main application (not in this schema)
model SuperAdmin {
  id           String @id @default(uuid()) // Unique identifier
  email        String @unique // Admin email (must be unique)
  passwordHash String // Hashed password (never store plain)
  firstName    String // Admin first name
  lastName     String // Admin last name

  // Audit fields
  createdAt   DateTime  @default(now()) // When admin account was created
  updatedAt   DateTime  @updatedAt // Auto-updates on any change
  lastLoginAt DateTime? // Track last login time

  // Relationships
  createdAssessments Assessment[] @relation("CreatedBy") // Assessments created by this admin
  blacklistEntries   Blacklist[]  @relation("BlacklistedBy") // Blacklist entries created by this admin

  @@map("super_admins") // Table name in database
}

// Candidate table - Linked from main application
// This stores only assessment-related data for candidates
model Candidate {
  id        String  @id @default(uuid()) // Unique identifier (should match main app)
  email     String  @unique // Candidate email
  firstName String // Candidate first name
  lastName  String // Candidate last name
  phone     String? // Optional phone number

  //Agent which became the candidate and gave test
  agentId   String?
  agent     Agent?   @relation(fields: [agentId], references: [id], onDelete: SetNull)

  // CEFR proficiency tracking (updated after each assessment)
  overallCEFRLevel CEFRLevel? // Latest overall CEFR level

  // Status flags
  isBlacklisted Boolean @default(false) // Is candidate banned?
  isActive      Boolean @default(true) // Is account active?

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships - One candidate can have many of each:
  systemChecks          SystemCheck[] // All system validation checks
  identityVerifications IdentityVerification[] // All face verifications
  assessmentAttempts    CandidateAssessment[] // All assessment attempts
  proctoringLogs        ProctoringLog[] // All proctoring events
  proctoringSessions    ProctoringSession[] // All test sessions
  answers               Answer[] // All submitted answers
  speakingEvaluations   SpeakingEvaluation[] // All speaking scores
  reconnectionLogs      ReconnectionLog[] // All reconnection attempts
  blacklistEntries      Blacklist[] // Blacklist records (if banned)
  ViolationSnapshot     ViolationSnapshot[]

  @@index([email]) // Index for fast email lookups
  @@index([isBlacklisted]) // Index for filtering blacklisted candidates
  @@map("candidates")
}

// ============================================================================
// ASSESSMENT & QUESTION BANK MANAGEMENT
// ============================================================================

// Assessment Configuration - Defines the test structure
model Assessment {
  id            String  @id @default(uuid())
  title         String // Assessment name (e.g., "Language Proficiency Test")
  description   String? // Detailed description  // Assessment metadata
  totalDuration Int // Total test duration in minutes
  passingScore  Float? // Minimum score to pass (optional)
  maxAttempts   Int     @default(2) // Maximum attempts allowed per candidate

  // Scheduling
  startDate  DateTime? // When assessment becomes available
  endDate    DateTime? // When assessment closes
  isFlexible Boolean   @default(true) // Can take anytime within date range?

  // Proctoring settings
  requireCamera      Boolean @default(true) // Is camera mandatory?
  requireMicrophone  Boolean @default(true) // Is microphone mandatory?
  requireScreenShare Boolean @default(true) // Is screen sharing mandatory?
  faceCheckInterval  Int     @default(5) // Seconds between face checks

  // Violation settings
  violationThreshold Int @default(10) // Max violations before auto-submit
  graceViolations    Int @default(2) // First N violations are warnings only

  // Session recovery settings
  maxReconnects      Int @default(3) // Max allowed reconnections
  idleTimeoutMinutes Int @default(10) // Auto-submit after idle time

  // Status
  status AssessmentStatus @default(DRAFT)
  
  // ðŸ†• NEW FIELD - Assessment Type
  assessmentType AssessmentType @default(LANGUAGE)

  // Audit
  createdById String // Which admin created this
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relationships
  createdBy          SuperAdmin            @relation("CreatedBy", fields: [createdById], references: [id])
  sections           Section[] // Assessment has multiple sections
  attempts           CandidateAssessment[] // All candidate attempts
  proctoringSessions ProctoringSession[] // All test sessions

  @@index([status])
  @@index([assessmentType])
  @@index([createdById])
  @@map("assessments")
}


// Section - Assessment is divided into sections (Listening, Speaking, etc.)
model Section {
  id           String @id @default(uuid())
  assessmentId String // Which assessment this belongs to

  // Section details
  name            String // "Listening Comprehension", "Speaking", etc.
  description     String? // Section instructions
  orderIndex      Int // Display order (1, 2, 3...)
  durationMinutes Int // Time limit for this section

  // Question selection
  totalQuestions Int // How many questions to display
  randomize      Boolean @default(true) // Randomize question order?

  // Navigation rules
  allowSkip      Boolean @default(true) // Can skip questions?
  allowReview    Boolean @default(true) // Can mark for review?
  lockOnComplete Boolean @default(true) // Lock section after completion?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  assessment Assessment        @relation(fields: [assessmentId], references: [id], onDelete: Cascade)
  questions  QuestionSection[] // Questions in this section
  answers    Answer[] // Answers submitted for this section

  @@unique([assessmentId, orderIndex]) // Each section has unique order in assessment
  @@index([assessmentId])
  @@map("sections")
}
// Question Bank - Stores all questions
model Question {
  id String @id @default(uuid())

  // Question content
  questionType QuestionType // Audio MCQ, Speaking, Reading, Writing
  questionText String // Main question text

  // For audio questions (Listening Comprehension)
  audioFilePath String? // Path to audio file in storage
  audioFileName String? // Original filename
  audioFileSize Int? // File size in bytes
  audioDuration Int? // Duration in seconds

  // For reading questions
  readingPassage String? // Text passage for reading comprehension

  // For MCQ questions (both audio and reading)
  options       Json? // Array of options: ["Option A", "Option B", ...]
  correctAnswer String? // Correct answer (for auto-grading)

  // For writing questions
  wordCountMin Int? // Minimum word count
  wordCountMax Int? // Maximum word count

  // For speaking questions
  speakingPrompt   String? // Speaking task instructions
  speakingDuration Int? // Expected speaking duration in seconds

  // CEFR classification
  cefrLevel CEFRLevel // Which CEFR level this question tests

  // ðŸ†• NEW FIELDS - Task Classification
  taskLevel TaskLevel? // Level 1, 2, or 3 (A1-A2, B1-B2, C1-C2)
  sectionType String? // "WRITING" or "SPEAKING"
  assessmentType AssessmentType? // "LANGUAGE" or "SKILL"

  // Question metadata
  skillTested     String? // "Grammar", "Vocabulary", "Fluency", etc.
  difficultyScore Float? // Optional difficulty rating (1-10)

  // Usage tracking
  timesUsed Int    @default(0) // How many times used in assessments
  avgScore  Float? // Average score on this question

  // Status
  isActive Boolean @default(true) // Can be used in assessments?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  sections QuestionSection[] // Which sections include this question
  answers  Answer[] // All answers submitted for this question

  @@index([questionType])
  @@index([cefrLevel])
  @@index([taskLevel])
  @@index([sectionType])
  @@index([assessmentType])
  @@index([isActive])
  @@map("questions")
}


// Junction table - Maps questions to sections (many-to-many)
model QuestionSection {
  id         String @id @default(uuid())
  sectionId  String // Which section
  questionId String // Which question

  orderIndex Int? // Order within section (if not randomized)
  isRequired Boolean @default(true) // Must be answered?
  points     Float   @default(1.0) // Points for correct answer

  createdAt DateTime @default(now())

  // Relationships
  section  Section  @relation(fields: [sectionId], references: [id], onDelete: Cascade)
  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([sectionId, questionId]) // Each question appears once per section
  @@index([sectionId])
  @@index([questionId])
  @@map("question_sections")
}

// ============================================================================
// CANDIDATE ASSESSMENT ATTEMPTS
// ============================================================================

// Candidate Assessment - Tracks each attempt
model CandidateAssessment {
  id           String @id @default(uuid())
  candidateId  String // Which candidate
  assessmentId String // Which assessment

  // Attempt tracking
  attemptNumber Int // 1st attempt, 2nd attempt, etc.

  // Timing
  startedAt      DateTime? // When test started
  completedAt    DateTime? // When test finished
  submittedAt    DateTime? // When answers submitted
  totalTimeSpent Int? // Total time in seconds

  // Scoring
  totalScore Float? // Final score
  maxScore   Float? // Maximum possible score
  percentage Float? // Score percentage
  passed     Boolean? // Did candidate pass?

  // CEFR results (overall and per section)
  overallCEFRLevel CEFRLevel? // Overall CEFR level achieved
  cefrResults      Json? // Per-section CEFR: {"listening": "B1", "speaking": "B2"}

  // Verification status
  verificationStatus VerificationStatus @default(NOT_STARTED)
  systemCheckStatus  CheckStatus        @default(PENDING)

  // Violations and flags
  violationCount  Int     @default(0) // Total violations
  graceViolations Int     @default(0) // Violations that were warnings
  isFlagged       Boolean @default(false) // Flagged for review?
  flagReason      String? // Why flagged?

  // Session status
  sessionStatus SessionStatus @default(NOT_STARTED)

  // Reconnection tracking
  reconnectCount  Int @default(0) // How many times reconnected
  disconnectCount Int @default(0) // How many times disconnected

  // Auto-submission reason
  autoSubmitReason String? // "Time up", "Violation threshold", "Max reconnects"
  
  fullscreenEntered Boolean @default(false) // Was fullscreen entered?
  fullscreenEnteredAt DateTime? // When fullscreen was first entered
  fullscreenExitCount Int @default(0) // How many times fullscreen was exited

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  candidate            Candidate             @relation(fields: [candidateId], references: [id], onDelete: Cascade)
  assessment           Assessment            @relation(fields: [assessmentId], references: [id], onDelete: Cascade)
  systemCheck          SystemCheck? // One system check per attempt
  identityVerification IdentityVerification? // One identity verification per attempt
  proctoringSession    ProctoringSession? // One proctoring session per attempt
  answers              Answer[] // All answers for this attempt

  @@unique([candidateId, assessmentId, attemptNumber]) // Unique attempt number per candidate per assessment
  @@index([candidateId])
  @@index([assessmentId])
  @@index([sessionStatus])
  @@index([isFlagged])
  @@map("candidate_assessments")
}

// ============================================================================
// STEP 1: SYSTEM CHECKS (Environment Validation)
// ============================================================================

// System Check - Stores all Step 1 validation results
model SystemCheck {
  id          String  @id @default(uuid())
  candidateId String // Which candidate
  attemptId   String? @unique // Which assessment attempt (one check per attempt)

  // Device information
  browserName     String? // "Chrome", "Firefox", "Safari"
  browserVersion  String? // "120.0.6099.109"
  operatingSystem String? // "Windows 10", "macOS 14.0"
  deviceType      String? // "desktop", "mobile", "tablet"
  userAgent       String? // Full user agent string

  // Screen information
  screenWidth      Int? // Screen resolution width
  screenHeight     Int? // Screen resolution height
  viewportWidth    Int? // Browser viewport width
  viewportHeight   Int? // Browser viewport height
  devicePixelRatio Float? // For retina displays

  // Permission checks (CRITICAL)
  cameraPermission CheckStatus @default(PENDING)
  micPermission    CheckStatus @default(PENDING)
  screenPermission CheckStatus @default(PENDING)

  // Device functionality checks (CRITICAL)
  cameraWorking CheckStatus @default(PENDING) // Camera produces video?
  micWorking    CheckStatus @default(PENDING) // Mic detects audio?
  faceDetected  CheckStatus @default(PENDING) // Face visible in camera?

  // Network checks (CRITICAL)
  networkLatency Int? // Ping time in milliseconds
  downloadSpeed  Float? // Mbps (optional)
  uploadSpeed    Float? // Mbps (optional)
  networkStatus  CheckStatus @default(PENDING)

  // Security checks (WARNING level)
  ipAddress      String? // Candidate's IP address
  ipCountry      String? // Country from IP
  ipCity         String? // City from IP
  ipASN          String? // Autonomous System Number
  ipOrganization String? // ISP/Organization name
  isVpnDetected  Boolean     @default(false) // VPN/Proxy detected?
  vpnCheckStatus CheckStatus @default(PENDING)

  // Multiple monitor detection (WARNING level)
  multipleMonitors Boolean @default(false) // Multiple monitors suspected?
  monitorCount     Int     @default(1) // Estimated number of monitors

  // Overall result
  allChecksPassed  Boolean @default(false) // All critical checks passed?
  criticalFailures Json? // Array of failed critical checks
  warnings         Json? // Array of warnings

  // Raw data for debugging
  rawCheckData Json? // Store complete system info

  // Retry tracking
  retryCount Int @default(0) // How many times retried

  // Timestamps
  checkStartedAt   DateTime  @default(now())
  checkCompletedAt DateTime? // When all checks completed
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  // Relationships
  candidate Candidate            @relation(fields: [candidateId], references: [id], onDelete: Cascade)
  attempt   CandidateAssessment? @relation(fields: [attemptId], references: [id], onDelete: Cascade)

  @@index([candidateId])
  @@index([attemptId])
  @@index([allChecksPassed])
  @@map("system_checks")
}

// ============================================================================
// STEP 2: IDENTITY VERIFICATION (Face Matching)
// ============================================================================

// Identity Verification - Face capture and continuous verification
model IdentityVerification {
  id          String @id @default(uuid())
  candidateId String // Which candidate
  attemptId   String @unique // Which assessment attempt

  // Initial face capture (at verification step)
  faceImagePath      String? // Path to stored face image
  faceImageBase64    String? // Base64 fallback (for MVP)
  audioRecordingPath String? // Path to stored audio recording
  audioTranscription String? // What ASR heard
  audioOriginalText  String? // Original sentence displayed
  audioMatchScore    Float? // Similarity % (0-100)
  audioVerified      Boolean @default(false)
  audioAttemptCount  Int     @default(0) // Track retake count

  // Face embedding for matching (from face-api.js)
  faceEmbedding      Json? // Face descriptor array (128-dim vector)
  faceDescriptorHash String? // Hash for quick comparison

  // Initial verification result
  faceDetectedInitial Boolean @default(false) // Was face detected in initial capture?
  faceQualityScore    Float? // Face quality (0-1, higher is better)

  // Verification status
  verificationStatus VerificationStatus @default(NOT_STARTED)
  verificationMethod String? // "face-api.js", "manual", etc.

  // Continuous verification stats (during test)
  totalFramesChecked      Int    @default(0) // How many frames analyzed during test
  framesWithFace          Int    @default(0) // Frames where face was detected
  framesWithMultipleFaces Int    @default(0) // Frames with multiple faces
  framesWithMismatch      Int    @default(0) // Frames with different person
  avgMatchScore           Float? // Average face match score across test

  // Flags
  requiresManualReview Boolean   @default(false) // Flag for human review
  reviewNotes          String? // Notes from manual reviewer
  reviewedBy           String? // Admin ID who reviewed
  reviewedAt           DateTime? // When reviewed

  // Metadata
  verifiedAt DateTime? // When initial verification completed
  ipAddress  String? // IP at verification time

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  candidate          Candidate           @relation(fields: [candidateId], references: [id], onDelete: Cascade)
  attempt            CandidateAssessment @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  violationSnapshots ViolationSnapshot[] // Flagged violation frames

  @@index([candidateId])
  @@index([attemptId])
  @@index([verificationStatus])
  @@map("identity_verifications")
}

// Violation Snapshot - Stores flagged frames during test
model ViolationSnapshot {
  id             String @id @default(uuid())
  verificationId String // Which identity verification session
  candidateId    String // Which candidate
  sessionId      String // Which proctoring session

  // Snapshot details
  snapshotPath   String? // Path to image file
  snapshotBase64 String? // Base64 image (fallback)

  // Detection results
  faceDetected   Boolean // Was face detected?
  faceCount      Int     @default(0) // Number of faces
  faceMatchScore Float? // Match score with original face

  // Violation context
  violationType     ViolationType? // What violation occurred
  violationSeverity ViolationSeverity @default(MEDIUM)

  // Metadata
  capturedAt DateTime @default(now()) // When frame was captured

  // Relationships
  verification IdentityVerification @relation(fields: [verificationId], references: [id], onDelete: Cascade)
  candidate    Candidate            @relation(fields: [candidateId], references: [id], onDelete: Cascade)
  session      ProctoringSession    @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([verificationId])
  @@index([candidateId])
  @@index([sessionId])
  @@index([capturedAt])
  @@map("violation_snapshots")
}

// ============================================================================
// REAL-TIME PROCTORING & VIOLATION TRACKING
// ============================================================================

// Proctoring Session - Tracks entire test session
model ProctoringSession {
  id           String @id @default(uuid())
  candidateId  String // Which candidate  
  assessmentId String // Which assessment
  attemptId    String @unique // Which attempt (one session per attempt)

  // Session metadata
  sessionToken String @unique // Unique token for WebSocket auth

  // Timing
  sessionStartedAt DateTime? // When session started
  sessionEndedAt   DateTime? // When session ended
  lastHeartbeatAt  DateTime? // Last keep-alive ping

  // Status
  sessionStatus SessionStatus @default(NOT_STARTED)

  // Proctoring stats
  totalViolations    Int @default(0) // Total violations detected
  graceViolations    Int @default(0) // Violations that were warnings
  criticalViolations Int @default(0) // Critical violations

  // Recording metadata (if enabled)
  screenRecordingPath String? // Path to screen recording
  audioRecordingPath  String? // Path to audio recording
  recordingStartedAt  DateTime? // When recording started
  recordingEndedAt    DateTime? // When recording ended
  recordingFileSize   Int? // File size in bytes

  // Session termination
  terminatedReason String? // Why session ended
  isAutoSubmitted  Boolean @default(false) // Was test auto-submitted?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  candidate          Candidate           @relation(fields: [candidateId], references: [id], onDelete: Cascade)
  assessment         Assessment          @relation(fields: [assessmentId], references: [id], onDelete: Cascade)
  attempt            CandidateAssessment @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  proctoringLogs     ProctoringLog[] // All proctoring events
  violationSnapshots ViolationSnapshot[] // Flagged frames

  @@index([candidateId])
  @@index([assessmentId])
  @@index([sessionStatus])
  @@index([sessionToken])
  @@map("proctoring_sessions")
}

// Proctoring Log - Records every proctoring event
model ProctoringLog {
  id          String @id @default(uuid())
  sessionId   String // Which proctoring session
  candidateId String // Which candidate

  // Event details
  eventType        String // General event type
  violationType    ViolationType? // Specific violation type
  eventDescription String? // Human-readable description

  // Severity
  severity          ViolationSeverity @default(INFO)
  isViolation       Boolean           @default(false) // Is this a rule violation?
  countsTowardLimit Boolean           @default(false) // Does this count toward auto-submit threshold?

  // Face detection data (if applicable)
  faceDetected   Boolean? // Was face detected?
  faceCount      Int? // Number of faces
  faceMatchScore Float? // Match score with original

  // Browser activity (if applicable)
  tabVisible    Boolean? // Is tab visible?
  windowFocused Boolean? // Is window focused?
  isFullscreen  Boolean? // Is fullscreen active?

  // Additional context
  metadata   Json? // Any additional data
  userAction String? // What user did (if any)

  // Timestamp
  timestamp DateTime @default(now()) // When event occurred

  // Relationships
  session   ProctoringSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  candidate Candidate         @relation(fields: [candidateId], references: [id], onDelete: Cascade)

  @@index([sessionId, timestamp]) // Efficient time-range queries
  @@index([candidateId])
  @@index([violationType])
  @@index([severity])
  @@index([isViolation])
  @@map("proctoring_logs")
}

// ============================================================================
// SESSION RECOVERY & RECONNECTION TRACKING
// ============================================================================

// Reconnection Log - Tracks disconnections and reconnections
model ReconnectionLog {
  id          String @id @default(uuid())
  candidateId String // Which candidate
  attemptId   String // Which attempt

  // Event type
  eventType String // "DISCONNECTED" or "RECONNECTED"

  // Disconnect details
  disconnectReason   String? // "network_error", "browser_closed", etc.
  disconnectDuration Int? // Seconds offline (calculated on reconnect)

  // Network info
  ipAddress String? // IP at time of event
  userAgent String? // Browser info

  // Timestamp
  timestamp DateTime @default(now()) // When event occurred

  // Relationships
  candidate Candidate @relation(fields: [candidateId], references: [id], onDelete: Cascade)

  @@index([candidateId])
  @@index([attemptId])
  @@index([eventType])
  @@map("reconnection_logs")
}

// ============================================================================
// ANSWERS & RESPONSES
// ============================================================================

// Answer - Stores candidate's answers to questions
model Answer {
  id          String @id @default(uuid())
  candidateId String // Which candidate
  attemptId   String // Which attempt
  sectionId   String // Which section
  questionId  String // Which question

  // Answer content (varies by question type)
  answerText    String? // For MCQ, Writing, Fill-in-blank
  audioFilePath String? // For Speaking questions (temporary)

  // For writing questions
  wordCount      Int? // Actual word count
  characterCount Int? // Character count

  // Scoring (auto or manual)
  isCorrect Boolean? // For MCQ (auto-graded)
  score     Float? // Points earned
  maxScore  Float? // Maximum possible points

  // Grammar checking results (for writing)
  grammarErrors Json? // Array of grammar errors detected
  grammarScore  Float? // Grammar score (0-100)

  // Metadata
  isSkipped         Boolean @default(false) // Was question skipped?
  isMarkedForReview Boolean @default(false) // Marked for review?
  revisionCount     Int     @default(0) // How many times answer changed

  // Copy-paste detection
  copyPasteDetected Boolean @default(false) // Was copy-paste detected?
  pasteCount        Int     @default(0) // Number of paste attempts

  // Timing
  timeSpentSeconds Int? // Time spent on this question
  firstViewedAt    DateTime? // When first viewed
  lastModifiedAt   DateTime? // When last changed
  submittedAt      DateTime? // When submitted

  createdAt DateTime @default(now()) // When answer record created
  updatedAt DateTime @updatedAt // Auto-updates on change

  // Relationships
  candidate          Candidate           @relation(fields: [candidateId], references: [id], onDelete: Cascade)
  attempt            CandidateAssessment @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  section            Section             @relation(fields: [sectionId], references: [id], onDelete: Cascade)
  question           Question            @relation(fields: [questionId], references: [id], onDelete: Cascade)
  speakingEvaluation SpeakingEvaluation? // If speaking question

  @@unique([attemptId, questionId]) // One answer per question per attempt
  @@index([candidateId])
  @@index([attemptId])
  @@index([questionId])
  @@map("answers")
}

// ============================================================================
// SPEAKING ASSESSMENT - ASR EVALUATION
// ============================================================================

// Speaking Evaluation - Stores ASR analysis results
model SpeakingEvaluation {
  id          String @id @default(uuid())
  candidateId String // Which candidate
  answerId    String @unique // Which answer (one evaluation per answer)

  // Audio metadata
  audioFilePath String? // Path to audio file (temporary)
  audioDuration Int? // Duration in seconds
  audioFileSize Int? // File size in bytes

  // ASR Scores (0-100)
  fluencyScore       Float? // Fluency rating
  pronunciationScore Float? // Pronunciation rating
  grammarScore       Float? // Grammar correctness
  vocabularyScore    Float? // Vocabulary usage
  coherenceScore     Float? // Coherence and structure

  // Overall speaking score
  overallScore Float? // Average of all scores
  cefrLevel    CEFRLevel? // CEFR level for this response

  // Speech analysis
  wordsPerMinute   Float? // Speaking pace
  totalWords       Int? // Total words spoken
  uniqueWords      Int? // Vocabulary diversity
  fillerWords      Int? // "um", "uh", etc.
  pauseCount       Int? // Number of pauses
  avgPauseDuration Float? // Average pause length

  // Transcription
  transcription String? // Speech-to-text output

  // Grammar errors detected
  grammarErrors Json? // Array of grammar issues

  // Processing metadata
  asrProvider     String? // Which ASR service used
  processingTime  Int? // Time to process (ms)
  confidenceScore Float? // ASR confidence (0-1)

  // Audio deletion tracking
  audioDeleted   Boolean   @default(false) // Has audio file been deleted?
  audioDeletedAt DateTime? // When audio was deleted

  evaluatedAt DateTime? // When evaluation completed
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relationships
  candidate Candidate @relation(fields: [candidateId], references: [id], onDelete: Cascade)
  answer    Answer    @relation(fields: [answerId], references: [id], onDelete: Cascade)

  @@index([candidateId])
  @@index([answerId])
  @@map("speaking_evaluations")
}

// ============================================================================
// BLACKLIST MANAGEMENT
// ============================================================================

// Blacklist - Banned candidates
model Blacklist {
  id          String @id @default(uuid())
  candidateId String // Which candidate is blacklisted

  // Blacklist details
  reason            BlacklistReason // Why blacklisted
  reasonDescription String // Detailed explanation

  // Related data
  relatedAttemptId String? // Which attempt triggered blacklist
  violationCount   Int? // Total violations that led to ban

  // Ban duration
  isPermanent Boolean   @default(true) // Is ban permanent?
  bannedUntil DateTime? // If temporary, when does ban end?

  // Status
  isActive     Boolean   @default(true) // Is blacklist currently active?
  revokedAt    DateTime? // If unbanned, when?
  revokedBy    String? // Admin who revoked
  revokeReason String? // Why was ban lifted?

  // Audit
  blacklistedBy String // Admin who blacklisted
  blacklistedAt DateTime @default(now()) // When blacklisted
  updatedAt     DateTime @updatedAt

  // Relationships
  candidate Candidate  @relation(fields: [candidateId], references: [id], onDelete: Cascade)
  admin     SuperAdmin @relation("BlacklistedBy", fields: [blacklistedBy], references: [id])

  @@index([candidateId])
  @@index([isActive])
  @@index([reason])
  @@map("blacklist")
}

// ============================================================================
// EXTERNAL API ACCESS
// ============================================================================

// API Key - For external systems to access results
model APIKey {
  id String @id @default(uuid())

  // Key details
  keyName   String // Descriptive name
  apiKey    String @unique // The actual API key (hashed)
  keyPrefix String // First few chars (visible)

  // Permissions
  canReadResults Boolean @default(true) // Can fetch candidate results?
  canReadReports Boolean @default(false) // Can access full reports?
  canWebhook     Boolean @default(true) // Can receive webhooks?

  // Webhook configuration
  webhookUrl    String? // URL to send webhooks
  webhookEvents Json? // Array of events to notify

  // Usage tracking
  lastUsedAt    DateTime? // Last API call
  totalRequests Int       @default(0) // Total API calls made

  // Rate limiting
  rateLimit       Int @default(1000) // Requests per hour
  rateLimitWindow Int @default(3600) // Window in seconds

  // Status
  isActive  Boolean   @default(true) // Is key active?
  expiresAt DateTime? // Optional expiration

  // Audit
  createdBy String // Admin who created key
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  revokedAt DateTime? // If revoked, when?
  revokedBy String? // Admin who revoked

  @@index([apiKey])
  @@index([isActive])
  @@map("api_keys")
}

// ============================================================================
// AUDIT LOG (Optional - for comprehensive tracking)
// ============================================================================

// Audit Log - Tracks all system actions for compliance
model AuditLog {
  id String @id @default(uuid())

  // Who performed the action
  actorType  String // "SuperAdmin", "Candidate", "System"
  actorId    String? // ID of actor
  actorEmail String? // Email of actor

  // What action was performed
  actionType String // "CREATE", "UPDATE", "DELETE", "LOGIN", etc.
  entityType String // "Assessment", "Question", "Candidate", etc.
  entityId   String? // ID of affected entity

  // Action details
  actionDescription String // Human-readable description
  oldValues         Json? // Previous state (for updates)
  newValues         Json? // New state (for updates)

  // Context
  ipAddress String? // IP address of actor
  userAgent String? // Browser/device info

  // Timestamp
  timestamp DateTime @default(now()) // When action occurred

  @@index([actorType, actorId])
  @@index([actionType])
  @@index([entityType, entityId])
  @@index([timestamp])
  @@map("audit_logs")
}

// ============================================================================
// LISTENING COMPREHENSION - AUDIO CLIP TRACKING (Optional Enhancement)
// ============================================================================

// Audio Clip Usage - Track which audio clips were played for each candidate
model AudioClipUsage {
  id          String @id @default(uuid())
  candidateId String // Which candidate
  attemptId   String // Which attempt
  questionId  String // Which question

  // Audio details
  audioFilePath String // Path to audio clip
  audioDuration Int // Duration in seconds

  // Playback tracking
  playCount     Int       @default(0) // How many times played
  firstPlayedAt DateTime? // When first played
  lastPlayedAt  DateTime? // When last played

  // Completion tracking
  wasCompleted      Boolean @default(false) // Did they listen to full audio?
  completionPercent Float? // % of audio listened to

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([attemptId, questionId]) // One record per question per attempt
  @@index([candidateId])
  @@index([attemptId])
  @@map("audio_clip_usage")
}

